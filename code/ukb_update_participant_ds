#!/bin/bash
# Update an existing dataset of a UKbiobank participant
#
# This script expects a preconfigured DataLad dataset as created by
# `ukb_create_participant_ds`. It takes two mandatory positional arguments:
#
# 1. Path to the dataset to be updated
# 2. Path to a UKB keyfile for authorizing the download
#
# The dataset may or may not have any downloaded content already.
#
set -e -u

dspath="$1"
keyfile="$(readlink -f "$2")"

# it is critical that the rest of the script runs in the dataset
# we are doing an `rm -f` below !!!
cd "$dspath"

if [ -n "$(git status --porcelain)" ]; then
  echo "Refuse to operate on dirty dataset"
  exit 1
fi

oldbranch="$(git rev-parse --abbrev-ref HEAD)"

# make sure we are in incoming whether or not the branch existed
git checkout incoming

# record current state
oldcommit=$(git rev-parse incoming)

# download stage
mkdir -p .git/tmp/ukb
# first wipe out all prev. downloaded zip files so we could detect
# when some files are no longer available
rm -f *.zip
# redownload, run with explicit mode, because we just deleted the ZIP files
# and that is OK
datalad run --explicit --output . -m "Update from UKbiobank" ukbfetch -v -a"$keyfile" -b.ukbbatch -o.git/tmp/ukb/fetched.ls

# stop here, if run made no commit
[ "$oldcommit" = "$(git rev-parse incoming)" ] && git checkout $oldbranch && exit 0

# update extracted content branch
git checkout incoming-processed

# mark the incoming change as merged (but we do not actually want any branch content)
git merge -m "Merge incoming" --strategy=ours incoming

# wipe out the branch content, because we want to start from clean slate every time
# give full branch name to make more robust
[ -n "$(git ls-tree --name-only --full-name incoming-processed)" ] && git ls-tree --name-only --full-name incoming-processed -z -r | xargs -0 rm -f

# discover all files present in the last commit in 'incoming'
# (diff will also report on clean files). These should all be ZIP files.
# We know that ZIP files can not only be added by the logic above, hence
# we need to filter out deletions
for f in $(datalad -f json diff -f incoming^ -t incoming | jq '. | select(.state == "added", .state == "modified", .state != "deleted") | .path' | tr -d '"'); do
	f=$(basename $f)
	# the space in the expression below is a feature
	[ "${f: -4}" != ".zip" ] && continue || true
	# --use-current-dir due to https://github.com/datalad/datalad/issues/3995
	datalad add-archive-content \
		--use-current-dir \
		--allow-dirty \
		--no-commit \
		--key $(basename $(git cat-file -p "incoming:$f"))
done

# save whatever the state is now, `save` will discover deletions automatically
# and also commit them -- wonderful!
datalad save -m "Track ZIP file content"

# and update user-facing branch
git checkout master
git merge -m "Merge update from UKbiobank" incoming-processed

# be nice
git checkout $oldbranch
